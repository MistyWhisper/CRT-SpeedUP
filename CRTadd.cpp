#include <bits/stdc++.h>
#include <gmp.h>
#include <gmpxx.h>
#include <chrono>

using namespace std;
using namespace std::chrono;

mpz_class modInverse(mpz_class a, mpz_class m) {
    mpz_class m0 = m, t, q;
    mpz_class x0 = 0, x1 = 1;

    if (m == 1) {
        return 0;  // 如果m为1，逆元不存在
    }
    // 使用扩展欧几里得算法
    while (a > 1) {
        q = a / m;
        t = m;
        m = a % m, a = t;
        t = x0;
        x0 = x1 - q * x0;
        x1 = t;
    }
    if (x1 < 0) {
        x1 += m0;
    }

    return x1;
}

int main() {
    auto start = high_resolution_clock::now(); // 记录开始时间

    mpz_class a("16166392929715882314249214437276545792712394133361090522908954536376469330942458115273697678762316818139204858869377207505725336108241185870077056699177864285686686456445249265624061325817479777056914575451404894384557435546564423919825745922738689769097117273149997322479649170353428672323455777784407558577734977811384383208003787435954785863027418138765535619385113231437810710170809371019013636908862039104359971684357506280693120486100115346221478615604249398628999152337028957452843481796504463327483235778263079606667296973353343312915920670393544213996299017456710805644105850259166736242332994152602810712064"), b("16284741340621562272625855831400092980067536110911318125565681875588595753570148145400152273775218112561893034995800173885708684103177065708071764288483705166255403048366517561858498085157285631940200919341971548076977328925382611503426227225247757776191532480127669338017567539096865192618649451121043045829402144559637563172923288076042302597017369955301154474578269258022274917419497580177278744060464250225182519061256170309102294135339501256515925750418336143860543802061311746306817445792086487217142703097284039193831772061006003220038291978375927407363768263558150855465805014609526668425659004358697999663104");
    mpz_class p1("132872155597415695517204800320225475210600169996924038794570770032541953128245570479121311561005386592327193418866898729125260912230933795197781659801533135422858199544978362491253569254219209862953778212147146534610916355487245132267952621363498618513476571366956589947518823812787667764674357785144657739751"), p2("99044218653805280864724545574863958746312617659428843725163579555322474623896413044622795368965753124712683459962275442426624060860602983907649118564110909438124241103744451786095350614131111954127746326053353496658459213979532010236003976206666179135815375217530819181185102017197901876055869337631073018837");
    mpz_class n = p1 * p2;
    mpz_class N1 = n / p1, N2 = n / p2;

    // 计算模逆元，确保它们存在
    mpz_class inv1 = modInverse(N1, p1);
    mpz_class inv2 = modInverse(N2, p2);

    // 计算 a 和 b 对每个素数 p1 和 p2 的模
    mpz_class a_mod_p1 = a % p1, b_mod_p1 = b % p1;
    mpz_class a_mod_p2 = a % p2, b_mod_p2 = b % p2;

    // 使用中国剩余定理
    mpz_class a_res = (a_mod_p1 * inv1 * N1 + a_mod_p2 * inv2 * N2) % n;
    mpz_class b_res = (b_mod_p1 * inv1 * N1 + b_mod_p2 * inv2 * N2) % n;

    mpz_class res = (a_res % n + b_res % n) % n;

    cout << res << endl;

    auto stop = high_resolution_clock::now(); // 记录结束时间
    auto duration = duration_cast<nanoseconds>(stop - start); // 计算时间差
    cout << "Time:" << duration.count() << " ns" << endl; // 输出时间差
    system("pause");
    return 0;
}
